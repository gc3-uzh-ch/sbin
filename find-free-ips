#!/usr/bin/env python
# -*- coding: utf-8 -*-#
# @(#)find-free-ips
#
#
# Copyright (C) 2014, GC3, University of Zurich. All rights reserved.
#
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

__docformat__ = 'reStructuredText'
__author__ = 'Antonio Messina <antonio.s.messina@gmail.com>'

from collections import namedtuple
from fnmatch import fnmatch
from itertools import groupby
from netaddr import IPNetwork, IPAddress
from operator import itemgetter
import argparse
import copy
import os
import re
import sys
import yaml

from s3it.inventory import parse_files

default_networks = {
    'gc3':
    { 'net': IPNetwork('192.168.160.0/22'),
      'used': [],
      'free': [], },
    'mngt':
    { 'net': IPNetwork('192.168.164.0/22'),
    'used': [],
      'free': [], },
    'public':
    { 'net': IPNetwork('130.60.24.0/24'),
      'used': [],
      'free': [], },
    'ceph':
    {'net': IPNetwork('10.130.0.0/16'),
     'used': [],
     'free': [], },
    'es':
    {'net': IPNetwork('10.129.0.0/16'),
     'used': [],
     'free': [], },
    'esmngt':
    {'net': IPNetwork('10.128.0.0/16'),
     'used': [],
     'free': [], },
    'switches':
    {'net': IPNetwork('10.128.160.0/24'),
     'used': [],
     'free': [], },
 }

def parse_etc_hosts(fd, only_networks=None, skip_comments=True):
    networks = copy.deepcopy(default_networks)

    all_ips = []
    for line in fd:
        linefields = line.strip().split()
        if not skip_comments:
            linefields = line.strip('#').strip().split()
        try:
            ip = IPAddress(linefields[0])
            for net in networks:
                if only_networks and net not in only_networks:
                    continue
                if ip in networks[net].get('net', []):
                    networks[net]['used'].append(ip)
        except:
            continue

    for name, net in networks.items():
        if 'net' in net:
            net['free'] = [ip for ip in net['net'] if ip not in net['used'] and ip not in (net['net'].network, net['net'].broadcast)]

    return networks

def parse_inventory_database(path, only_networks):
    networks = copy.deepcopy(default_networks)
    networks = {k:v for k,v in networks.items() if k in only_networks}

    all_ips = []
    data = parse_files([path], '*.yaml')
    for host in data.hosts.values():
        for iface in host['interfaces']:
            if 'ip' not in iface:
                continue
            ip = IPAddress(iface['ip'])
            for net in networks:
                if ip in networks[net].get('net', []):
                    networks[net]['used'].append(ip)

    for name, net in networks.items():
        if 'net' in net:
            net['free'] = [ip for ip in net['net'] if ip not in net['used'] and ip not in (net['net'].network, net['net'].broadcast)]
    return networks


# ask for how_many in mngt and gc3, with the same last bit
def find_good_ranges(networks, how_many=10, gap=256*4):
    good_ranges = []
    # cfr. http://stackoverflow.com/questions/2154249/identify-groups-of-continuous-numbers-in-a-list
    #
    for network in networks:
        for k, g in groupby(enumerate(network), lambda (i,x):x-i):
            r = map(itemgetter(1), g)
            if len(r) >= how_many:
                yield r

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Find a set of consecutive free IPs on a network")
    def is_valid_dir(parser, path):
        if os.path.isdir(path):
            return path
        else:
            parser.error("Non-existent directory %s" % path)

    parser.add_argument('-i','--inventory-dir', metavar='PATH', help='Path to inventory database', type=lambda x: is_valid_dir(parser, x))
    parser.add_argument('-c', '--count', type=int, default=10, help='How many consecutive hosts')
    parser.add_argument('--net', required=True, action='append', help="""Which network to use. Currently defined networks:
    %s""" % str.join(', ', ["%s:%s" % (name, net['net']) for name, net in default_networks.items()]))

    def new_networks(parser, netstring):
        fields = netstring.split(':')
        if len(fields) != 2:
            parser.error("Invalid format for argument '%s'. Should be in form 'name:A.B.C.D/N'" % netstring)
        try:
            result = {fields[0]: {'net': IPNetwork(fields[1]),
                                  'free': [],
                                  'used': [],}}
            return result
        except Exception as ex:
            parser.error("Invalid argument %s: %s" % (fields[1], ex))

    args = parser.parse_args()

    for net in args.net:
        if net and net not in default_networks:
            parser.error("Network '%s' not defined." % net)

    networks = parse_inventory_database(args.inventory_dir, args.net)
    ranges = find_good_ranges([networks[net]['free'] for net in args.net], args.count)
    for r in ranges:        
        print("{}: {} - {}".format(len(r), r[0], r[-1]))
